Template Meta-Programming
=========================
The progression of modern C++ can be described as evolving through two distinct paradigms. First from the legacy C to object-oriented C++ with classes. The modern paradigm can be described as a shift toward [Template Meta Programming](https://en.wikipedia.org/wiki/Template_metaprogramming).

Meta-Programming differs from conventional programming in a number of ways.  A prominent distinction is that meta-programming is more accurately programming the compiler how and what to compile rather than programming a processor what to execute. Meta-programming closely interacts with the compiler typically before machine code is generated. It is close interaction with the compiler that makes meta-programming the preferential platform of generic library developers.

> It's worth noting that I make a distinction between generic and object-oriented. In this context, generic programming may or may not be OO while OO is not generic. OO refers to concrete or abstract class types while generic programming is more or less type-less.

The C++ template engine is a [Turing Complete](https://en.wikipedia.org/wiki/Turing_completeness) "language" within C++ that continues to grow and yield powerful new language extensions with each adopted revision of the language standard. Because the features were an after-thought and more or less discovered by accident, the syntax is cumbersome, unfamiliar and non-intuitive. It requires significant dedication to navigate the plethora of caveats but the payoffs can be significant.

The goal of this informative is to shed light on the C++ template engine and present the topic in an easy to understand format with descriptive examples, each step building on the prior. This work will by no means be a complete corpus on this lengthy topic. The intent is to be a spring-board by which some basic knowledge can be derived. See the 'Suggested Reading' section at the bottom of this page for more detailed information. 

Template Basics
---------------
At it's most basic level, templates permit a generic or type-less algorithm to work with various concrete types. When a template is used the compiler will qualify the generic types into the concrete types required to run. For example, here's a simple function template:
~~~{.c}
template <typename _Ty> _Ty square(_Ty src){ return src * src; }
~~~
This function template can be reused to square shorts, ints, longs, doubles or any other type that supports operator *.  The compiler will substitute the `_Ty` parameter with other concrete types at compile time to _generate_ the various overloaded versions of the function. Consider the following usage scenarios:

~~~{.c}
char cVal = 8;
int iVal = 123;
double dVal = 3.14;

std::cout << square<char>(cVal) << std::endl;
std::cout << square<int>(iVal) << std::endl;
std::cout << square<double>(dVal) << std::endl;
~~~

The compiler will substitute the generic _Ty parameter with a char, int and double respectively to generate the following specializations:

~~~{.c}
char square(char src){ return src * src; }
int square(int src){ return src * src; }
double square(double src){ return src * src; }
~~~
The above three *specializaitons* are generated by the compiler based on the usage scenarios despite the single instance of the `square` function template in code. This feature can obviously save a lot of typing and technical debit when a single definition needs maintaining instead of three. The notable take-away from TMP at this point is **code generation**.


The above specializations are qualified with the type surrounded in angle brackets. (e.g. square<**char**>) Function templates have a special ability to evaluate certain parameter types based on usage scenarios. The above template can be simplified:
~~~{.c}
template <typename _Ty> auto square(_Ty src) -> _Ty { return src * src; }
~~~
In this example, the `auto` keyword is a placeholder ordering the compiler to evaluate the type at a later time.  This new version of `square` can be used without the type qualifiers:
~~~{.c}
char cVal = 8;
int iVal = 123;
double dVal = 3.14;

std::cout << square(cVal) << std::endl;
std::cout << square(iVal) << std::endl;
std::cout << square(dVal) << std::endl;
~~~
Here the types are unambiguous because they can be deduced based on the usage scenario so there's no need to qualify them. If the type cannot be deduced based on the usage scenario it must be qualified in the template parameter list. Within the definition of the specialization the parameters must be listed in the order that they're declared.
### Class Templates
The previous examples demonstrate _function templates_. _Class templates_ are another template variation:
~~~{.c}
template <typename _Ty> struct CheckedPointer{
    CheckedPointer(_Ty * newval) : _Ptr(newval){}
    _Ty * operator->() { assert(_Ptr); return _Ptr; }
    void delete_it(){
        delete _Ptr;
        _Ptr = nullptr;
    }
    _Ty * _Ptr;
};
~~~
This is a very simple class template that checks if the contained pointer to type _Ty is not null during every access. This template could be used in code like:
~~~{.c}
int main(){
    struct user{
        int userid;
        int lastlogin;
    };
    CheckedPointer<user> oUser(new user);
    oUser->userid = 1234;
    oUser->delete_it();
    oUser->lastlogin = 111980; //assert
}
~~~
### Type and Non-Type Parameters
Templates can accept type and non-type parameters. Type parameters refer to all the compiler intrinsic and user defined types such as classes and structures. Compiler intrinsics are identified with keywords such as `int`, `short`, `double`, etc.  Non-type parameters included values that can be evaluated at compile time such as static constant pointers and references.

Here's an example of a class template that accepts a type and non-type template parameters:
~~~{.c}
template <typename _Ty, size_t _Dims> struct StaticArray{
    _Ty value[_Dims];
};
~~~
This very simply declares a fixed sized array. It's of little use but can be used in code as:
~~~{.c}
int main(){
    StaticArray<int, 10> oArr;
    oArr.value[0] = 123;
    return oArr.value[0];
}
~~~
The first parameter is a type parameter, the second is a non-type parameter. Here's another example that pre-computes a value:
~~~{.c}
template <typename _Ty, size_t _Dims> struct StaticArray{
    static const bool EvenNumberOfElements = (0 == ( _Dims %2 ));
    ...
};
~~~
Here the template engine performs the division and comparison at compile time and stores the result in the static constant. This consumes no clock cycles at run-time to calculate. Integral types can be calculated with ease by the template engine and leveraged in various ways to achieve significant run-time performance improvements. This is the name of the game with TMP: interacting with the compiler to generate, pre-compute and pre-compile as much as possible to reduce run-time overhead and reduce the volume of maintainable code. 
Specialization
--------------
The generic form of a template is declared with the following convention:

|                 |keyword   |input params   |type       | name        |
|----------------:|:--------:|:-------------:|:---------:|:-----------:|
|function template|`template`|`<int _Factor>`|   `int`   |`fnTemplate` |
|class template   |`template`|`<int _Factor>`|   `struct`|`CTemplate`  |


The input parameters on the generic form appear on the left-hand-side of the template name.

A class or function template is specialized when a generic parameter is explicitly qualified in a declaration. For example, assume a compile-time constant is calculated:
~~~{.c}
template <int _Factor> int Factoral(){
  return _Factor * Factoral<_Factor - 1>();
}
~~~
This is a meta-function that calculates `value` at compile time by recursively multiplying the value of the `_Factor` parameter by `_Factor-1`. At first glance this may seem correct, however, there's at least two problems with it. First, at some point during the recursive calculation the value of _Factor will reach zero and invalidate the computation (anything multiplied by zero is zero). Next, there is no terminating condition for the recursive calls so the compile will fail at some point due to infinite recursion. For this meta-function to operate as expected a specialization is introduced that terminates the recursion and corrects the calculation:
~~~{.c}
template <> int Factoral<1>(){
  return 1;
}
~~~
The fully specialized form of a template is declared with the following convention:

|                 |keyword   |empty input params|type       | name       |output parameters|
|----------------:|:--------:|:----------------:|:---------:|:----------:|:---------------:|
|function template|`template`|`<>`              |   `int`   |`fnTemplate`|<0>              |
|class template   |`template`|`<>`              |   `struct`|`CTemplate` |<5>              |

Notice the specialized values appear on the right-hand-side of the template name.  This distinguishes specialized templates from their generic form. Input parameters appear to the left of the name while output parameters appear to the right.

During compilation, the compiler chooses the most specialized version of a template over a lesser specialized version whenever it's encountered. In this case, the specialized  `template <> struct Factoral<1>` is more specialized than the generic `template <size_t _Factor> struct Factoral` so the compiler chooses it while recursively calculating the value. Assume this function template is used as:
~~~{.c}
int main(){
  return Factoral<5>();
}
~~~
>>The compiler generate 4 specializations before instantiating the explicit Factoral<1> specialization. Here is an excerpt of the listing file generated by MSVC14 with debugging enabled:
~~~{.asm}
PUBLIC	??$Factoral@$04@@YAHXZ				; Factoral<5>
PUBLIC	??$Factoral@$03@@YAHXZ				; Factoral<4>
PUBLIC	??$Factoral@$02@@YAHXZ				; Factoral<3>
PUBLIC	??$Factoral@$01@@YAHXZ				; Factoral<2>
PUBLIC	??$Factoral@$00@@YAHXZ				; Factoral<1>
~~~
`Factoral<5>` through `Factoral<2>` are compiler generated specializations that will be called in the expected order. The beauty of TMP can be demonstrated in the listing of the release build. Since the values are deterministic at compile-time, the optimizer eliminates it all:
~~~{.c}
; int main() {
; return Factoral<5>();
00E11000  mov         eax,78h  
00E11005  ret  
~~~



Suggested Reading
-----------------    


 * [Advanced Metaprogramming in Classic C++](https://www.amazon.com/Advanced-Metaprogramming-Classic-Davide-Gennaro/dp/1484210115) 
 * [C++ Templates: The Complete Guide](https://www.amazon.com/Templates-Complete-Guide-David-Vandevoorde/dp/0201734842)
 * [C++ Template Metaprogramming: Concepts, Tools, and Techniques from Boost and Beyond](https://www.amazon.com/Template-Metaprogramming-Concepts-Techniques-Beyond/dp/0321227255)
 * [Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14](https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996)
 * [Modern C++ Design: Generic Programming and Design Patterns Applied](https://www.amazon.com/Modern-Design-Generic-Programming-Patterns/dp/0201704315)



Copyright :copyright: David Mott 2016  

